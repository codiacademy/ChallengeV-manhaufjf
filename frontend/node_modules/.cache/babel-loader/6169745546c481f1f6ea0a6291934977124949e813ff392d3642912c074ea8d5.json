{"ast":null,"code":"import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\nlet handoffFrameTime;\nfunction handoffOptimizedAppearAnimation(elementId, valueName, frame) {\n  const optimisedValueName = transformProps.has(valueName) ? \"transform\" : valueName;\n  const storeId = appearStoreId(elementId, optimisedValueName);\n  const optimisedAnimation = appearAnimationStore.get(storeId);\n  if (!optimisedAnimation) {\n    return null;\n  }\n  const {\n    animation,\n    startTime\n  } = optimisedAnimation;\n  if (startTime === null || window.MotionHandoffIsComplete) {\n    /**\n     * If the startTime is null, this animation is the Paint Ready detection animation\n     * and we can cancel it immediately without handoff.\n     *\n     * Or if we've already handed off the animation then we're now interrupting it.\n     * In which case we need to cancel it.\n     */\n    appearAnimationStore.delete(storeId);\n    frame.render(() => frame.render(() => {\n      try {\n        animation.cancel();\n      } catch (error) {}\n    }));\n    return null;\n  } else {\n    /**\n     * Otherwise we're starting a main thread animation.\n     *\n     * Record the time of the first handoff. We call performance.now() once\n     * here and once in startOptimisedAnimation to ensure we're getting\n     * close to a frame-locked time. This keeps all animations in sync.\n     */\n    if (handoffFrameTime === undefined) {\n      handoffFrameTime = performance.now();\n    }\n    /**\n     * We use main thread timings vs those returned by Animation.currentTime as it\n     * can be the case, particularly in Firefox, that currentTime doesn't return\n     * an updated value for several frames, even as the animation plays smoothly via\n     * the GPU.\n     */\n    return handoffFrameTime - startTime || 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"names":["transformProps","appearAnimationStore","appearStoreId","handoffFrameTime","handoffOptimizedAppearAnimation","elementId","valueName","frame","optimisedValueName","has","storeId","optimisedAnimation","get","animation","startTime","window","MotionHandoffIsComplete","delete","render","cancel","error","undefined","performance","now"],"sources":["D:/Programmer/Codi/Challenge/Magic/Merge/ChallengeVI-manhaufjf/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"sourcesContent":["import { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nlet handoffFrameTime;\nfunction handoffOptimizedAppearAnimation(elementId, valueName, frame) {\n    const optimisedValueName = transformProps.has(valueName)\n        ? \"transform\"\n        : valueName;\n    const storeId = appearStoreId(elementId, optimisedValueName);\n    const optimisedAnimation = appearAnimationStore.get(storeId);\n    if (!optimisedAnimation) {\n        return null;\n    }\n    const { animation, startTime } = optimisedAnimation;\n    if (startTime === null || window.MotionHandoffIsComplete) {\n        /**\n         * If the startTime is null, this animation is the Paint Ready detection animation\n         * and we can cancel it immediately without handoff.\n         *\n         * Or if we've already handed off the animation then we're now interrupting it.\n         * In which case we need to cancel it.\n         */\n        appearAnimationStore.delete(storeId);\n        frame.render(() => frame.render(() => {\n            try {\n                animation.cancel();\n            }\n            catch (error) { }\n        }));\n        return null;\n    }\n    else {\n        /**\n         * Otherwise we're starting a main thread animation.\n         *\n         * Record the time of the first handoff. We call performance.now() once\n         * here and once in startOptimisedAnimation to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (handoffFrameTime === undefined) {\n            handoffFrameTime = performance.now();\n        }\n        /**\n         * We use main thread timings vs those returned by Animation.currentTime as it\n         * can be the case, particularly in Firefox, that currentTime doesn't return\n         * an updated value for several frames, even as the animation plays smoothly via\n         * the GPU.\n         */\n        return handoffFrameTime - startTime || 0;\n    }\n}\n\nexport { handoffOptimizedAppearAnimation };\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,uCAAuC;AACtE,SAASC,oBAAoB,QAAQ,aAAa;AAClD,SAASC,aAAa,QAAQ,gBAAgB;AAE9C,IAAIC,gBAAgB;AACpB,SAASC,+BAA+BA,CAACC,SAAS,EAAEC,SAAS,EAAEC,KAAK,EAAE;EAClE,MAAMC,kBAAkB,GAAGR,cAAc,CAACS,GAAG,CAACH,SAAS,CAAC,GAClD,WAAW,GACXA,SAAS;EACf,MAAMI,OAAO,GAAGR,aAAa,CAACG,SAAS,EAAEG,kBAAkB,CAAC;EAC5D,MAAMG,kBAAkB,GAAGV,oBAAoB,CAACW,GAAG,CAACF,OAAO,CAAC;EAC5D,IAAI,CAACC,kBAAkB,EAAE;IACrB,OAAO,IAAI;EACf;EACA,MAAM;IAAEE,SAAS;IAAEC;EAAU,CAAC,GAAGH,kBAAkB;EACnD,IAAIG,SAAS,KAAK,IAAI,IAAIC,MAAM,CAACC,uBAAuB,EAAE;IACtD;AACR;AACA;AACA;AACA;AACA;AACA;IACQf,oBAAoB,CAACgB,MAAM,CAACP,OAAO,CAAC;IACpCH,KAAK,CAACW,MAAM,CAAC,MAAMX,KAAK,CAACW,MAAM,CAAC,MAAM;MAClC,IAAI;QACAL,SAAS,CAACM,MAAM,CAAC,CAAC;MACtB,CAAC,CACD,OAAOC,KAAK,EAAE,CAAE;IACpB,CAAC,CAAC,CAAC;IACH,OAAO,IAAI;EACf,CAAC,MACI;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAIjB,gBAAgB,KAAKkB,SAAS,EAAE;MAChClB,gBAAgB,GAAGmB,WAAW,CAACC,GAAG,CAAC,CAAC;IACxC;IACA;AACR;AACA;AACA;AACA;AACA;IACQ,OAAOpB,gBAAgB,GAAGW,SAAS,IAAI,CAAC;EAC5C;AACJ;AAEA,SAASV,+BAA+B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}