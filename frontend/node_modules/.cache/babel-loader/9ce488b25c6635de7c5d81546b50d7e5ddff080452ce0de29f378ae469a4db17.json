{"ast":null,"code":"import { observeTimeline } from '../render/dom/scroll/observe.mjs';\nimport { supportsScrollTimeline } from '../render/dom/scroll/supports.mjs';\nclass GroupPlaybackControls {\n  constructor(animations) {\n    // Bound to accomodate common `return animation.stop` pattern\n    this.stop = () => this.runAll(\"stop\");\n    this.animations = animations.filter(Boolean);\n  }\n  then(onResolve, onReject) {\n    return Promise.all(this.animations).then(onResolve).catch(onReject);\n  }\n  /**\n   * TODO: Filter out cancelled or stopped animations before returning\n   */\n  getAll(propName) {\n    return this.animations[0][propName];\n  }\n  setAll(propName, newValue) {\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i][propName] = newValue;\n    }\n  }\n  attachTimeline(timeline) {\n    const cancelAll = this.animations.map(animation => {\n      if (supportsScrollTimeline() && animation.attachTimeline) {\n        animation.attachTimeline(timeline);\n      } else {\n        animation.pause();\n        return observeTimeline(progress => {\n          animation.time = animation.duration * progress;\n        }, timeline);\n      }\n    });\n    return () => {\n      cancelAll.forEach((cancelTimeline, i) => {\n        if (cancelTimeline) cancelTimeline();\n        this.animations[i].stop();\n      });\n    };\n  }\n  get time() {\n    return this.getAll(\"time\");\n  }\n  set time(time) {\n    this.setAll(\"time\", time);\n  }\n  get speed() {\n    return this.getAll(\"speed\");\n  }\n  set speed(speed) {\n    this.setAll(\"speed\", speed);\n  }\n  get startTime() {\n    return this.getAll(\"startTime\");\n  }\n  get duration() {\n    let max = 0;\n    for (let i = 0; i < this.animations.length; i++) {\n      max = Math.max(max, this.animations[i].duration);\n    }\n    return max;\n  }\n  runAll(methodName) {\n    this.animations.forEach(controls => controls[methodName]());\n  }\n  play() {\n    this.runAll(\"play\");\n  }\n  pause() {\n    this.runAll(\"pause\");\n  }\n  cancel() {\n    this.runAll(\"cancel\");\n  }\n  complete() {\n    this.runAll(\"complete\");\n  }\n}\nexport { GroupPlaybackControls };","map":{"version":3,"names":["observeTimeline","supportsScrollTimeline","GroupPlaybackControls","constructor","animations","stop","runAll","filter","Boolean","then","onResolve","onReject","Promise","all","catch","getAll","propName","setAll","newValue","i","length","attachTimeline","timeline","cancelAll","map","animation","pause","progress","time","duration","forEach","cancelTimeline","speed","startTime","max","Math","methodName","controls","play","cancel","complete"],"sources":["D:/Programmer/Codi/Challenge/Magic/Merge/ChallengeVI-manhaufjf/node_modules/framer-motion/dist/es/animation/GroupPlaybackControls.mjs"],"sourcesContent":["import { observeTimeline } from '../render/dom/scroll/observe.mjs';\nimport { supportsScrollTimeline } from '../render/dom/scroll/supports.mjs';\n\nclass GroupPlaybackControls {\n    constructor(animations) {\n        // Bound to accomodate common `return animation.stop` pattern\n        this.stop = () => this.runAll(\"stop\");\n        this.animations = animations.filter(Boolean);\n    }\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline) {\n        const cancelAll = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                animation.attachTimeline(timeline);\n            }\n            else {\n                animation.pause();\n                return observeTimeline((progress) => {\n                    animation.time = animation.duration * progress;\n                }, timeline);\n            }\n        });\n        return () => {\n            cancelAll.forEach((cancelTimeline, i) => {\n                if (cancelTimeline)\n                    cancelTimeline();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get startTime() {\n        return this.getAll(\"startTime\");\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nexport { GroupPlaybackControls };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}