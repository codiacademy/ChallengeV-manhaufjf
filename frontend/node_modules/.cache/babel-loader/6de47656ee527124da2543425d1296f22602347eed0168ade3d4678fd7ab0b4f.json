{"ast":null,"code":"import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff,\n/**\n * Currently used to remove values from will-change when an animation ends.\n * Preferably this would be handled by event listeners on the MotionValue\n * but these aren't consistent enough yet when considering the different ways\n * an animation can be cancelled.\n */\nonEnd) => onComplete => {\n  const valueTransition = getValueTransition(transition, name) || {};\n  /**\n   * Most transition values are currently completely overwritten by value-specific\n   * transitions. In the future it'd be nicer to blend these transitions. But for now\n   * delay actually does inherit from the root transition if not value-specific.\n   */\n  const delay = valueTransition.delay || transition.delay || 0;\n  /**\n   * Elapsed isn't a public transition option but can be passed through from\n   * optimized appear effects in milliseconds.\n   */\n  let {\n    elapsed = 0\n  } = transition;\n  elapsed = elapsed - secondsToMilliseconds(delay);\n  let options = {\n    keyframes: Array.isArray(target) ? target : [null, target],\n    ease: \"easeOut\",\n    velocity: value.getVelocity(),\n    ...valueTransition,\n    delay: -elapsed,\n    onUpdate: v => {\n      value.set(v);\n      valueTransition.onUpdate && valueTransition.onUpdate(v);\n    },\n    onComplete: () => {\n      onComplete();\n      valueTransition.onComplete && valueTransition.onComplete();\n      onEnd && onEnd();\n    },\n    onStop: onEnd,\n    name,\n    motionValue: value,\n    element: isHandoff ? undefined : element\n  };\n  /**\n   * If there's no transition defined for this value, we can generate\n   * unqiue transition settings for this value.\n   */\n  if (!isTransitionDefined(valueTransition)) {\n    options = {\n      ...options,\n      ...getDefaultTransition(name, options)\n    };\n  }\n  /**\n   * Both WAAPI and our internal animation functions use durations\n   * as defined by milliseconds, while our external API defines them\n   * as seconds.\n   */\n  if (options.duration) {\n    options.duration = secondsToMilliseconds(options.duration);\n  }\n  if (options.repeatDelay) {\n    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n  }\n  if (options.from !== undefined) {\n    options.keyframes[0] = options.from;\n  }\n  let shouldSkip = false;\n  if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n    options.duration = 0;\n    if (options.delay === 0) {\n      shouldSkip = true;\n    }\n  }\n  if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {\n    shouldSkip = true;\n    options.duration = 0;\n    options.delay = 0;\n  }\n  /**\n   * If we can or must skip creating the animation, and apply only\n   * the final keyframe, do so. We also check once keyframes are resolved but\n   * this early check prevents the need to create an animation at all.\n   */\n  if (shouldSkip && !isHandoff && value.get() !== undefined) {\n    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n    if (finalKeyframe !== undefined) {\n      frame.update(() => {\n        options.onUpdate(finalKeyframe);\n        options.onComplete();\n      });\n      // We still want to return some animation controls here rather\n      // than returning undefined\n      return new GroupPlaybackControls([]);\n    }\n  }\n  /**\n   * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n   * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n   * optimised animation.\n   */\n  if (!isHandoff && AcceleratedAnimation.supports(options)) {\n    return new AcceleratedAnimation(options);\n  } else {\n    return new MainThreadAnimation(options);\n  }\n};\nexport { animateMotionValue };","map":{"version":3,"names":["secondsToMilliseconds","getDefaultTransition","getValueTransition","isTransitionDefined","MotionGlobalConfig","instantAnimationState","getFinalKeyframe","frame","AcceleratedAnimation","MainThreadAnimation","GroupPlaybackControls","animateMotionValue","name","value","target","transition","element","isHandoff","onEnd","onComplete","valueTransition","delay","elapsed","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","onStop","motionValue","undefined","duration","repeatDelay","from","shouldSkip","type","current","skipAnimations","get","finalKeyframe","update","supports"],"sources":["D:/Programmer/Codi/Challenge/Magic/Master/ChallengeV-manhaufjf/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs"],"sourcesContent":["import { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getValueTransition, isTransitionDefined } from '../utils/transitions.mjs';\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\nimport { GroupPlaybackControls } from '../GroupPlaybackControls.mjs';\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff, \n/**\n * Currently used to remove values from will-change when an animation ends.\n * Preferably this would be handled by event listeners on the MotionValue\n * but these aren't consistent enough yet when considering the different ways\n * an animation can be cancelled.\n */\nonEnd) => (onComplete) => {\n    const valueTransition = getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: \"easeOut\",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n            onEnd && onEnd();\n        },\n        onStop: onEnd,\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\nexport { animateMotionValue };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}